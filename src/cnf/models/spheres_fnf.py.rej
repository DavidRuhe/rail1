diff a/src/cnf/models/spheres_fnf.py b/src/cnf/models/spheres_fnf.py	(rejected hunks)
@@ -155,6 +155,67 @@ class ConditionalPointNetFNF(nn.Module):
         x = torch.cat([queries, z, n], dim=-1)
 
         return self.mlp(x)
+    
+import math
+
+class RFF(nn.Module):
+    def __init__(self, input_dim, hidden_dim, learnable_coefficients=True, std=1.0):
+        super(RFF, self).__init__()
+        assert hidden_dim % 2 == 0, "hidden_dim should be even."
+        self.hidden_dim = hidden_dim
+        self.learnable_coefficients = learnable_coefficients
+        self.std = std
+
+        # Embedding layer
+        self.coefficients = nn.Linear(input_dim, hidden_dim, bias=False)
+        nn.init.normal_(self.coefficients.weight, mean=0.0, std=hidden_dim // 2)
+        # Store pi
+        self.pi = math.pi
+
+    def forward(self, x):
+        # Scaling input by pi
+        x = self.pi * x * 2
+        
+        if self.learnable_coefficients:
+            x_proj = self.coefficients(x)
+        else:
+            # Stop gradient for non-learnable coefficients
+            with torch.no_grad():
+                x_proj = self.coefficients(x)
+
+        # Apply standard deviation scaling
+        x_proj = self.std * x_proj
+
+        # Calculate sin and cos projections
+        sin_part = torch.sin(x_proj[..., :self.hidden_dim // 2])
+        cos_part = torch.cos(x_proj[..., self.hidden_dim // 2:])
+
+        # Concatenate sin and cos parts
+        return torch.cat((sin_part, cos_part), dim=-1)
+    
+
+class FNF(nn.Module):
+    def __init__(self):
+        super().__init__()
+
+        # self.ff = FourierSeriesEmbedding(3, 256)
+        self.ff = RFF(1, 64, learnable_coefficients=False)
+        self.mlp = nn.Sequential(
+            nn.Linear(192, 512),
+            nn.GELU(),
+            nn.Linear(512, 512),
+            nn.GELU(),
+            nn.Linear(512, 512),
+            nn.GELU(),
+            nn.Linear(512, 512),
+            nn.GELU(),
+            nn.Linear(512, 1),
+        )
+
+    def forward(self, input):
+        ff = self.ff(input[..., None])
+        ff = ff.reshape(*input.shape[:-1], -1)
+        return self.mlp(ff)
 
 
 def conditional_pointnet_fnf():
@@ -168,3 +229,6 @@ def shapes_fnf(input_dim, output_dim, input_conditioning_dim):
 def spheres_fnf(input_dim, output_dim, input_conditioning_dim):
 
     return SpheresFNF(input_dim, output_dim, input_conditioning_dim)
+
+def bunny_fnf(*args, **kwargs):
+    return FNF(*args, **kwargs)
\ No newline at end of file
